02/20/08

What are the basics that are needed for leg simulation?  If I just want to check that box2d works:

-World
    -Handles overall simulation loop, wrapper around b2World
    *constructor creates world,
      * adds gravity
      * creates ground
    *Simulation step may just call world->step
      * my world maintains time step info?
        -will that ever be dynamic?
      *Also has to update muscle forces in leg

-Leg
    -Actual geometry of the legged creature
    -Displays geometry
    -In future I want to be able to specify geometry through data files,
     but thats easy enough to add.
    * For now lets just try our hand at creating a 1, 2 and then 3 segment leg
      and dropping it.
    -Also stores list of muscles
    -In future creature needs a brain which interacts with muscles

-Graphics wrapper?  Probably not necessary just yet, and if I keep it simple
  now then it won't be a problem later to change.
    -Just drawing lines with SDL (and perhaps SDL_gfx), nothing hard about that

-Muscles
    -Springs that connect fixed points
    -Variable length I think... or K, its unclear.. maybe both.

02/23/08

I probably do need a rendering engine to translate from Box2D coordinates to
screen coordinates.  You know, something like one pixel is a centimeter, and
origin is lower left or centerbottom, or whatever.

So I want to be able to specify the center of the screen in boxspace, and
number of pixels in a meter (basic unit in boxspace).  And flip the Y so
increaseing Y goes up. 

03/02/08

Implementing NEAT:  

The genome is the link structure, so the brain itself can implement crossover...  But actually, since we need to keep global track of innovation numbers per generation, so should create a mating pool method that will run experiments, keep population and create new population.  That makes sense.  I can think about generalizing it later if necessary.  Clearly its useless right now

Lets first implement the brains then, since that is fun.  I think I decided on method similar to ken's code, at the first step run it until some activation gets to all the nodes (especially output).  Otherwise pass current activations one step forward.  So the brain contains lists of neurons and links:

Neuron:
    -ID number
    -Sensor, Output or Hidden
    -Has received active input?
    -current input activation (sum of input links last activations)
    -previous steps full activation

Links:
    -ID and/or pointer to input and output neuron of the link
    -Weight
    -enabled?
    -Innovation number

So process of running a network:
    -Initialize sensor activation
    -If first iteration, then activate network
	-set input activation to 0, all hidden/output nodes inactive
	-Repeat until all nodes active:
	-Go over the links
	    -If link is enabled and input is active
		-Set output active, 
		-add weight*input last activation to output activation sum
	-Go over the nodes.
	    -If active, set last activation to sigmoid(activation sum)
    -Any other iteration:  Repeat once:
	-set input activation to 0
	-Go over the links
	    -If link is enabled
		-add weight*input last activation to output activation sum
	-Go over the nodes.
	    -set last activation to sigmoid(activation sum)


So pass in inputs per step as array of values (between 0 and 1), return outputs as array of values between 0 and 1.  Let the instantiating body interpret the rest, and return fitness value.

03/06/08

So it appears that about 3/4 of NEAT are hacks, which is all well and good, its whats necessary to make anything work.  I should probably impliment what I feel like and play with it, discuss with georgina, etc.  My goal is more code simplicity and speed than anything else.  The species idea is nice, along with inter species breeding.  I need to think about the node and innovation number scheme... I am guessing I am probably wrong about sequential nature of the neurons, which slightly complicates my code, but probably not greatly.

03/09/08

For full NEAT genetic algorithm, what do I need:

Species
    -One genome is the representative member used to identify who
     belongs in the species.
    -Stores set of genomes that all belong to one species
    -For each genome, keep a fitness value
	*May need to normalize fitness for species size
    -Need a method to randomly select one member by fitness


GeneticPool
    *Main class, stores the population, populates the next generation, etc.
    -Population: list of genomes
	*In this case genome is a list of network connections
	*May in fact not need single population list, but store by species
    -Species: list of sets of species
	*Each species stores a representative species
	*Then list of genomes of its members
    -Stores fitness function
	*impliments fitness class that is given a genome and returns fitness
	 value
    -Creates new generation
	*Calculate fitness values of entire population, species by species if
	 necessary.
	    *Report average/best fitness for this generation,
	    *Store overall champions genome
	*Calculate how many offspring each species will receive, remove dead
	 or whatever as necessary.
	*Go through each species
	    Champion stays on
	    For the number of offspring that species gets:
		Select one member from species weighted by fitness
		With some probability chose mother from same species
		 or another.
		Combine mother and father to form new genome
		Add genome to next generation
		    Find appropriate species, etc.
    -Store innovation numbers per generation(?)
    -Mate two genomes to form a new genome
	*Crossover of genes, etc etc
	*Mutation of weights, addition of nodes/links


09/17/08

Its been awhile since I have thought about this.  Huh, who knew that all my plans for summer would fail.  Lets see if I can make a little progress on this everyday now...

So what do I have, from a NEAT perspective:

Network and Neuron
    -A not especially fast implementation of network and neuron
	*not fast and not tested I should say
    -Takes in a genome (which is just an array of Links), and creates new
     network
    -a function run which takes in an array of input values and produces an 
     array of outputs

For just a simple genetic algorithm what do I need (ie no speciation, no structural mutation):
    -Population of genomes
    -Ability to plug in various fitness functions
    -Mate two genomes, produces a third genome
    -Run experiment one generation
	-Go over all members of population, find fitness of each
	    -As said above, do some book keeping:
	    *Report average/best fitness for this generation
	    *Store overall champions genome
	-Create new generation
	    -Champion stays on
	    -To fill rest of next generation:
		pick two genomes randomly, by fitness
		Mate them, add offspring to next generation
	

Now how general do I want to make this?  Lets start with not very.  

Well, ok, a little.  At least lets have a genome class and fitness function class.  That should be enough to implement a straight forward fairly generic genetic algorithm implementation.  Haven't thought much how speciation fits into this, but I think thats the easy part.  Innovation numbers is something else.

Genome:
    -Mate (const genome &parent) -> Genome offspring
    -Mutate ()
	*Need to set global experiment options somewhere.  Pass it around, or what?
    -Load/unload from file... possibly not as easy as java, but I bet I can figure a way...
    -Clone -> Genome clone
	*for passing on champion, etc.

Fitness Function:
    -Score (Genome *g) -> double score

09/20/08

I bet I can get genetic algorithm without speciation running real quick, if I define genomes and fitness function as above.

09/22/08

Mating.. need to figure that one out.  So we are given two lists of links and the goal is to form a new genome with the links of both parents, with one parents dominating if they line up... ohhh... interesting.

So assuming that innovation numbers are in sorted order we do a merging trick:

Go over both lists
    If one head innovation number less than other, pass that through to child
	increment that parent
    if tied:
	with some probability take from dominant parent (p1 of p1.mate(p2))
	otherwise average strength

There are some details about calculating number of neurons, and if the id's will stay consistent somehow... and if should copy around links or create new ones, etc.  Also need to find dominant parent when selecting them at the beginning.

10/18/08

Lets put some thought into structural mutation...

First type is adding a new links:
    -Randomly select two neurons, add a new link between them with some small
     weight.  
	*Creates one new link
	*need to check innovation to see if this has been added before, find
	 appropriate innovation number.

Second type is adding new node over existing link
    -Select one link randomly, must be enabled?
	*Disable this link
	*Check innovation, see if this link has been split so far
	    if so, find appropriate innov info (innov of pre/post, new neuron
	    number)
	*Create new neuron with new number of next neuron id
	*Create two new links, set weight of one to 1, and old weight to
	 the other.

So global info I need to keep track of (either overall, or each generation)
-Innovation tracking:
    -Add link innovation
	*Index by two neuronIDs that are being connected
	    -stores the innovation number for this link
    -Add node innovation
	*Index by innovation number of link being split
	    -stores the innovation number of two new links, new neuron ID
    -Next Innovation number
    -Next Neuron ID

So up to now the genetic algorithm is actually real generic.  Do I want to break that by including NEAT innovation?  It probably won't end up being super intwined... yeah, lets just do that now and if I ever need different genetic algorithm later I can pull this out.  Abstract away innovation and species for use with other genome definitions.

11/22/08

ToDo:

So I have an xor experiment running, but at the moment I don't actually know if its working.  Time to implement more debugging/inspection/experiment features.  This means:

-Write network to file
    *Must be human readable.
    *XML?
-For each generation also report mean size of a network, and size of best
 network
-Create experiment file, contains parameters to recreate an experiment
    *Network parameters
    *Genetic algorithm parameters
    *Name of files
    *Where to save files
    *again, XML?
-Save best network in each generation (if changes?)

boy, do I gain anything from xml, except perhaps experience playing with XML.  Lets do some quick searching for free XML parsing library.

03/06/09

Huh, been awhile.

Ok, lets try for speciation, I am betting once I get this architecture into my memory I can implement that easily.

Once I have NEAT reasonably working on xor test (not entirely sure what I am expecting, but an improvement of maximum fitness over 500 generations is one thing), the immediate plan is:
    -Debug (valgrind?)
    -Profile
	-Any spots where small scale parallelization is warranted, or just ignore it?
    -Read in parameters
    -save output in usable format
	-Both experimental output and network specifications
	*Screw XML for now, just do it in text, can change that later and
	 convert
    -Implement Pole balancing test?

Ahh, experimenting with xor I think I have found a parameter that seemed to be causing XOR to fail.  The probability of randomly resetting the weight seems to have done the trick, or rather it being too large.  I will need to do more rigerous experiments to verify that, but if I set it to 0.2 then can never really get above 75 (max 100), but if I set this prob to 0 then can get to 0.98.

04/01/09

I still don't have proper debugging output to inspect the actual structure of the NEAT solutions to xor, although I am reasonably confident that they are correct.  I should add an additional output that tests the classifier for a looser more correct xor test, setting some threshold and seeing if the binary values are correct... pretty sure a correct network will solve it in very few generations.

04/05/09

NEAT does solve xor reasonably quickly, and I bet I could do some parameter tuning to improve that further.  It would be easy to do this in a fairly general way if I do better command line parsing for experiment parameters:

I should load experiment parameters:
    -From command line (pass argv, argc to exp Parameters)
    -From a file (read file on command line, pass to expParameter)

I bet I can do one or both pretty nicely, but the question is if I care at the moment...

I want to do speciation first.  Lets summarize the speciation procedure, what is necessary to implement and how to implement:

Necessary procedures:
    -Compatability distance between two genomes:
	linear combination of number of excess genes, disjoint genes, and difference in weight of shared genes.
	*Not sure I agree with the difference of definition of excess and disjoint, so how about we just combine them to nonmatching genes, normalized by number of total genes (in larger genome) (in his experiments first two weights are equal, so they might as well be summed)

    -Given compatability threshold, find first species cluster where compatability between representative and genome is less than this threshold
	-If no species matches, form new species

    -Individual fitness now shared, so divide by size of the species it is in
    (thus large species naturally shrink)
    
    -Selecting for mating:
	Given some interspecies mating parameter p, with probability 1-p mate
	for a genome will come from its own species, otherwise from outside.
    
New parameters:
    -compatability distance weights, cG and cW (gene diff weight, weight difference weight) (suggested defaults, 1.0 and 0.4)
    -compatability threshold (suggested default, 3.0)
    -interspecies mating parameter p

New structures:
    -List of species
	*Each species has:
	 -a list of pointers to its members
	 -representative member (first member in list?)
	 -total fitness of members

** As I start to store multiple pointers to each genome, I should make it a shared_ptr (which is almost always the best procedure anyway).

07/19/09

I guess its my three month check in... Let us see what trivial accomplishment I can do today.

Speciation.. where should that go...

Compatability should be part of Genome implementation, so put that there (either static function taking in two genomes, or genome.compat(other)... 

Oooh, this would have been a subtle issue, but are the innovation numbers guaranteed to be ascending in the links list for the genome?  I think it depends on how I use the innovation store, but might as well sort them anyway to defeat this and not be too clever from the start. 

Now I'm going to need species, which is a simple structure, but what are necessary operators:

Generating next generation:
    Find fitness function of all population, 
	-Go by species of last generation, finding sum of that species
	 fitness
    


